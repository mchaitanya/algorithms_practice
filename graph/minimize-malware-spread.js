// https://leetcode.com/problems/minimize-malware-spread/
// tags - graph
/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function (graph, initial) {
  const n = graph.length;
  // Find connected components with union-find.
  const uf = new UnionFind(n);
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      if (graph[i][j] === 1) uf.union(i, j);
    }
  }

  // Map each root to the size of its component.
  const map1 = new Map();
  for (let i = 0; i < n; i++) {
    const root = uf.find(i);
    map1.set(root, (map1.get(root) || 0) + 1);
  }

  let minNode = n;
  // Map each initial node's root to its count.
  const map2 = new Map();
  for (const node of initial) {
    if (node < minNode) minNode = node;
    const root = uf.find(node);
    map2.set(root, (map2.get(root) || 0) + 1);
  }

  let nodeRemove = n;
  let numNodesSaved = 0;
  for (const node of initial) {
    const root = uf.find(node);
    if (map2.get(root) > 1) continue;
    const size = map1.get(root);
    if (size > numNodesSaved || (size === numNodesSaved && node < nodeRemove)) {
      numNodesSaved = size;
      nodeRemove = node;
    }
  }
  return numNodesSaved === 0 ? minNode : nodeRemove;
};

class UnionFind {
  constructor(n) {
    this.parent = new Array(n).fill(0).map((v, i) => i);
  }

  find(x) {
    if (x === this.parent[x]) return x;
    const root = this.find(this.parent[x]);
    this.parent[x] = root;
    return root;
  }

  union(x, y) {
    const rootX = this.find(x);
    const rootY = this.find(y);
    if (rootX !== rootY) this.parent[rootY] = rootX;
  }
}
